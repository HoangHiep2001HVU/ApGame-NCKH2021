{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { useEffect, useState, useDebugValue, useRef } from 'react';\nimport * as TrackPlayer from \"./index\";\nimport TrackPlayerEvents from \"./eventTypes\";\n\nvar usePlaybackState = function usePlaybackState() {\n  var _useState = useState(TrackPlayer.STATE_NONE),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useEffect(function () {\n    var sub = TrackPlayer.addEventListener(TrackPlayer.TrackPlayerEvents.PLAYBACK_STATE, function (data) {\n      setState(data.state);\n    });\n    return function () {\n      sub.remove();\n    };\n  }, []);\n  return state;\n};\n\nvar useTrackPlayerEvents = function useTrackPlayerEvents(events, handler) {\n  var savedHandler = useRef();\n  useEffect(function () {\n    savedHandler.current = handler;\n  }, [handler]);\n  useEffect(function () {\n    if (__DEV__) {\n      var allowedTypes = Object.values(TrackPlayerEvents);\n      var invalidTypes = events.filter(function (type) {\n        return !allowedTypes.includes(type);\n      });\n\n      if (invalidTypes.length) {\n        console.warn('One or more of the events provided to useTrackPlayerEvents is ' + (\"not a valid TrackPlayer event: \" + invalidTypes.join('\\', \\'') + \". \") + 'A list of available events can be found at ' + 'https://react-native-kit.github.io/react-native-track-player/documentation/#events');\n      }\n    }\n\n    var subs = events.map(function (event) {\n      return TrackPlayer.addEventListener(event, function (payload) {\n        return savedHandler.current(_objectSpread(_objectSpread({}, payload), {}, {\n          type: event\n        }));\n      });\n    });\n    return function () {\n      subs.forEach(function (sub) {\n        return sub.remove();\n      });\n    };\n  }, events);\n};\n\nvar useInterval = function useInterval(callback, delay) {\n  var savedCallback = useRef();\n  useEffect(function () {\n    savedCallback.current = callback;\n  });\n  useEffect(function () {\n    if (!delay) return;\n    var id = setInterval(savedCallback.current, delay);\n    return function () {\n      return clearInterval(id);\n    };\n  }, [delay]);\n};\n\nvar useWhenPlaybackStateChanges = function useWhenPlaybackStateChanges(callback) {\n  useTrackPlayerEvents([TrackPlayerEvents.PLAYBACK_STATE], function (_ref) {\n    var state = _ref.state;\n    callback(state);\n  });\n  useEffect(function () {\n    var didCancel = false;\n\n    var fetchPlaybackState = function fetchPlaybackState() {\n      var playbackState;\n      return _regeneratorRuntime.async(function fetchPlaybackState$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(TrackPlayer.getState());\n\n            case 2:\n              playbackState = _context.sent;\n\n              if (!didCancel) {\n                callback(playbackState);\n              }\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    fetchPlaybackState();\n    return function () {\n      didCancel = true;\n    };\n  }, []);\n};\n\nvar usePlaybackStateIs = function usePlaybackStateIs() {\n  for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n\n  var _useState3 = useState(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      is = _useState4[0],\n      setIs = _useState4[1];\n\n  useWhenPlaybackStateChanges(function (state) {\n    setIs(states.includes(state));\n  });\n  return is;\n};\n\nvar useTrackPlayerProgress = function useTrackPlayerProgress() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n  var initialState = {\n    position: 0,\n    bufferedPosition: 0,\n    duration: 0\n  };\n\n  var _useState5 = useState(initialState),\n      _useState6 = _slicedToArray(_useState5, 2),\n      state = _useState6[0],\n      setState = _useState6[1];\n\n  var getProgress = function getProgress() {\n    var _await$Promise$all, _await$Promise$all2, position, bufferedPosition, duration;\n\n    return _regeneratorRuntime.async(function getProgress$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(Promise.all([TrackPlayer.getPosition(), TrackPlayer.getBufferedPosition(), TrackPlayer.getDuration()]));\n\n          case 2:\n            _await$Promise$all = _context2.sent;\n            _await$Promise$all2 = _slicedToArray(_await$Promise$all, 3);\n            position = _await$Promise$all2[0];\n            bufferedPosition = _await$Promise$all2[1];\n            duration = _await$Promise$all2[2];\n            setState({\n              position: position,\n              bufferedPosition: bufferedPosition,\n              duration: duration\n            });\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var needsPoll = usePlaybackStateIs(TrackPlayer.STATE_PLAYING, TrackPlayer.STATE_BUFFERING);\n  useInterval(getProgress, needsPoll ? interval : null);\n  return state;\n};\n\nmodule.exports.usePlaybackState = usePlaybackState;\nmodule.exports.useTrackPlayerEvents = useTrackPlayerEvents;\nmodule.exports.useTrackPlayerProgress = useTrackPlayerProgress;","map":{"version":3,"sources":["E:/hiep/NCKH2021/AppGame/node_modules/react-native-track-player/lib/hooks.js"],"names":["useEffect","useState","useDebugValue","useRef","TrackPlayer","TrackPlayerEvents","usePlaybackState","STATE_NONE","state","setState","sub","addEventListener","PLAYBACK_STATE","data","remove","useTrackPlayerEvents","events","handler","savedHandler","current","__DEV__","allowedTypes","Object","values","invalidTypes","filter","type","includes","length","console","warn","join","subs","map","event","payload","forEach","useInterval","callback","delay","savedCallback","id","setInterval","clearInterval","useWhenPlaybackStateChanges","didCancel","fetchPlaybackState","getState","playbackState","usePlaybackStateIs","states","is","setIs","useTrackPlayerProgress","interval","initialState","position","bufferedPosition","duration","getProgress","Promise","all","getPosition","getBufferedPosition","getDuration","needsPoll","STATE_PLAYING","STATE_BUFFERING","module","exports"],"mappings":"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","sourcesContent":["import { useEffect, useState, useDebugValue, useRef } from 'react';\nimport * as TrackPlayer from './index';\nimport TrackPlayerEvents from './eventTypes';\n\n/**\n * @description\n *   Get current playback state and subsequent updatates\n */\nconst usePlaybackState = () => {\n    const [state, setState] = useState(TrackPlayer.STATE_NONE)\n\n    useEffect(() => {\n        const sub = TrackPlayer.addEventListener(TrackPlayer.TrackPlayerEvents.PLAYBACK_STATE, data => {\n            setState(data.state)\n        })\n\n        return () => {\n            sub.remove()\n        }\n    }, [])\n\n    return state\n}\n\n/**\n * @description\n *   Attaches a handler to the given TrackPlayer events and performs cleanup on unmount\n * @param {Array<string>} events - TrackPlayer events to subscribe to\n * @param {(payload: any) => void} handler - callback invoked when the event fires\n */\nconst useTrackPlayerEvents = (events, handler) => {\n    const savedHandler = useRef();\n\n    useEffect(() => {\n        savedHandler.current = handler;\n    }, [handler]);\n\n    useEffect(\n        () => {\n            if (__DEV__) {\n                const allowedTypes = Object.values(TrackPlayerEvents);\n                const invalidTypes = events.filter(type => !allowedTypes.includes(type));\n                if (invalidTypes.length) {\n                    console.warn(\n                        'One or more of the events provided to useTrackPlayerEvents is ' +\n                        `not a valid TrackPlayer event: ${invalidTypes.join('\\', \\'')}. ` +\n                        'A list of available events can be found at ' +\n                        'https://react-native-kit.github.io/react-native-track-player/documentation/#events'\n                    )\n                }\n            }\n\n            const subs = events.map(event =>\n                TrackPlayer.addEventListener(event,\n                    (payload) => savedHandler.current({ ...payload, type: event })\n                )\n            );\n\n            return () => {\n                subs.forEach(sub => sub.remove());\n            }\n        },\n        events\n    );\n}\n\nconst useInterval = (callback, delay) => {\n    const savedCallback = useRef();\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    })\n\n    useEffect(() => {\n        if (!delay) return;\n        const id = setInterval(savedCallback.current, delay);\n        return () => clearInterval(id);\n    }, [delay]);\n}\n\nconst useWhenPlaybackStateChanges = callback => {\n    useTrackPlayerEvents(\n        [TrackPlayerEvents.PLAYBACK_STATE],\n        ({ state }) => {\n            callback(state);\n        }\n    );\n    useEffect(() => {\n        let didCancel = false;\n        const fetchPlaybackState = async () => {\n            const playbackState = await TrackPlayer.getState();\n            if (!didCancel) {\n                callback(playbackState);\n            }\n        }\n        fetchPlaybackState();\n        return () => { didCancel = true };\n    }, []);\n}\n\nconst usePlaybackStateIs = (...states) => {\n    const [is, setIs] = useState();\n    useWhenPlaybackStateChanges(state => {\n        setIs(states.includes(state));\n    });\n\n    return is;\n}\n\n/**\n * @description\n *   Poll for track progress for the given interval (in miliseconds)\n * @param {number} interval - ms interval\n * @returns {[\n *   {\n *      progress: number,\n *      bufferedPosition: number,\n *      duration: number\n *   },\n *   (interval: number) => void\n * ]}\n */\nconst useTrackPlayerProgress = (interval = 1000) => {\n    const initialState = {\n        position: 0,\n        bufferedPosition: 0,\n        duration: 0\n    };\n\n    const [state, setState] = useState(initialState);\n\n    const getProgress = async () => {\n        const [position, bufferedPosition, duration] = await Promise.all([\n            TrackPlayer.getPosition(),\n            TrackPlayer.getBufferedPosition(),\n            TrackPlayer.getDuration()\n        ])\n        setState({ position, bufferedPosition, duration });\n    }\n\n    const needsPoll = usePlaybackStateIs(\n        TrackPlayer.STATE_PLAYING,\n        TrackPlayer.STATE_BUFFERING\n    );\n    useInterval(getProgress, needsPoll ? interval : null);\n    return state;\n}\n\n\n// Exports\nmodule.exports.usePlaybackState = usePlaybackState\nmodule.exports.useTrackPlayerEvents = useTrackPlayerEvents\nmodule.exports.useTrackPlayerProgress = useTrackPlayerProgress\n"]},"metadata":{},"sourceType":"module"}